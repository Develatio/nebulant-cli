// Nebulant
// Copyright (C) 2020  Develatio Technologies S.L.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package executive

import (
	"fmt"
	"runtime/debug"
	"strconv"
	"sync"
	"time"

	"github.com/develatio/nebulant-cli/base"
	"github.com/develatio/nebulant-cli/blueprint"
	"github.com/develatio/nebulant-cli/cast"
	"github.com/develatio/nebulant-cli/ipc"
	"github.com/develatio/nebulant-cli/runtime"
	"github.com/develatio/nebulant-cli/storage"
	"github.com/develatio/nebulant-cli/util"
)

// ManagerStatusID int
type ManagerStatusID int

// NewManager func
func NewManager() *Manager {
	mng := &Manager{}
	// init vars calling reset
	mng.reset()
	return mng
}

// Manager struct
type Manager struct {
	// TODO: ir reemplazando las features del struct Manager
	// moviéndolas al struct Runtime en la medida de lo posible
	// ya que la idea es poder compartir Runtime entre stages y
	// actions. Runtime funcionará algo así como Context.
	// Será el punto de comunicación entre manager/stages/actors/debug
	Runtime *runtime.Runtime
	// The uuid generated by the builder or uuid asked to backend
	ExecutionUUID *string
	IRB           *blueprint.IRBlueprint
	// Coumunicate instruction to manager
	execInstruction chan *ExecCtrlInstruction
	// Logger instance with remote execution uuid configured
	Logger *cast.Logger
	// Comunicate Action exec
	// StageReport chan *stageReport
	// A map of threads tracked by &action -> &store
	syncThreads map[*blueprint.Action]base.IStore
	//
	// internalRegistry *Registry
	// ExternalRegistry *Registry
	//
	Stats *stats
	mu    sync.Mutex
}

type stats struct {
	stages  int
	actions int
}

func (m *Manager) reset() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.Runtime = nil
	m.ExecutionUUID = nil
	// m.StageReport = make(chan *stageReport, 1000)
	m.execInstruction = make(chan *ExecCtrlInstruction, 10)
	m.Stats = &stats{}
	m.Logger = &cast.Logger{}
	// m.stages = make(map[*Stage]string)
	// m.syncThreads = make(map[*blueprint.Action]base.IStore)
	// m.internalRegistry.reset()
	// m.ExternalRegistry.reset()
	// m.internalRegistry.Logger = m.Logger
	// m.ExternalRegistry.Logger = m.Logger
}

// GetLogger func
func (m *Manager) GetLogger() base.ILogger {
	return m.Logger
}

// PrepareIRB func
func (m *Manager) PrepareIRB(irb *blueprint.IRBlueprint) {
	// Reset all and prepare for new blueprint
	m.reset()
	m.mu.Lock()
	defer m.mu.Unlock()
	m.IRB = irb
	m.Runtime = runtime.NewRuntime(irb)
	m.ExecutionUUID = irb.ExecutionUUID
	// m.internalRegistry.ExecutionUUID = irb.ExecutionUUID
	// m.ExternalRegistry.ExecutionUUID = irb.ExecutionUUID
	if m.ExecutionUUID != nil {
		re := *m.ExecutionUUID
		m.Logger.ExecutionUUID = &re
	}
	// m.internalRegistry.SetManagerState(cast.EventManagerPrepareBPEnd)
	// m.ExternalRegistry.SetManagerState(cast.EventManagerPrepareBPEnd)
}

// WIP CONTINUACIÓN: eh, parece que manager ya puede mandar cosas a runtime y runtime, aunque
// sin terminar y con muchos WIP, ya medio gestiona las cosas: hacer que manager se entienda
// con runtime, sobre todo el status de arrancado/parado/etc, revisar los WIP de runtime
// y ver cómo comunicar todo para poder interactuar con el debugger

// RunStages func

// Run func
func (m *Manager) Run() error {
	exit := false
	defer func() {
		// m.internalRegistry.SetManagerState(cast.EventManagerOut)
		// m.ExternalRegistry.SetManagerState(cast.EventManagerOut)
		exit = true
		if r := recover(); r != nil {
			switch r.(type) {
			case *util.PanicData:
				panic(r)
			}
			panic(&util.PanicData{
				PanicValue: r,
				PanicTrace: debug.Stack(),
			})
		}
		cast.PushEvent(cast.EventManagerOut, m.ExecutionUUID)
	}()
	if exit {
		return nil
	}

	m.Logger.LogDebug("[Manager] Starting...")

	cast.PushEvent(cast.EventManagerStarting, m.ExecutionUUID)
	// m.internalRegistry.SetManagerState(cast.EventManagerStarting)
	// m.ExternalRegistry.SetManagerState(cast.EventManagerStarting)
	if m.IRB.StartAction == nil {
		return fmt.Errorf("[Manager] First action id not found")
	}

	// conf ipcs server
	ipcs, err := ipc.NewIPCServer()
	if err != nil {
		return err
	}
	go func() {
		err := ipcs.Accept()
		if err != nil {
			m.Logger.LogErr(err.Error())
		}
	}()
	defer ipcs.Close()

	// init store
	st := storage.NewStore()

	// set ipcs into store
	st.SetPrivateVar("IPCS", ipcs)

	// set vars from cli args
	for _, irbarg := range m.IRB.Args {
		if st.ExistsRefName(irbarg.Name) {
			err := st.Push(&base.StorageRecord{
				RefName: irbarg.Name,
				Aout:    nil,
				Value:   irbarg.Value,
				Action:  nil,
			}, "")
			if err != nil {
				return err
			}
		} else {
			err := st.Insert(&base.StorageRecord{
				RefName: irbarg.Name,
				Aout:    nil,
				Value:   irbarg.Value,
				Action:  nil,
			}, "")
			if err != nil {
				return err
			}
		}
	}

	m.Logger.ParanoicLogDebug(fmt.Sprintf("[Manager] Setting %s as start point", m.IRB.StartAction.ActionName))

	startActionContext := m.Runtime.NewAContext(nil, m.IRB.StartAction)
	m.Logger.ParanoicLogDebug("after set context")
	st.SetLogger(m.GetLogger())
	startActionContext.SetStore(st)
	m.Logger.ParanoicLogDebug("after set store")

	eventlistener := m.Runtime.NewEventListener()
	// start to run
	m.Runtime.NewThread(startActionContext)

	// m.RunStages([]*Stage{NewStage(m, startActionContext)})
	cast.PushEvent(cast.EventManagerStarted, m.ExecutionUUID)
	m.Logger.ParanoicLogDebug("after push event")
	// m.internalRegistry.SetManagerState(cast.EventManagerStarted)
	// m.ExternalRegistry.SetManagerState(cast.EventManagerStarted)
	m.Logger.ParanoicLogDebug("after set manager state")
	m.Logger.LogDebug("[Manager] Ready")
	// for run stats
	startTime := time.Now()

	eventlistener.WaitUntil([]base.EventCode{base.RuntimeEndEvent})

	m.mu.Lock()
	defer m.mu.Unlock()

	m.Logger.LogInfo("[Manager] out")
	elapsedTime := time.Since(startTime).String()
	m.Logger.LogInfo("[Manager] stats: " + strconv.Itoa(m.Stats.actions) + " actions executed by " + strconv.Itoa(m.Stats.stages) + " stages in " + elapsedTime)
	if m.ExecutionUUID != nil {
		m.Logger.LogDebug("Sending EventManagerOut for UUID" + *m.ExecutionUUID)
	} else {
		m.Logger.LogDebug("Sending EventManagerOut for no UUID")
	}

	cast.PushEvent(cast.EventManagerOut, m.ExecutionUUID)
	// m.internalRegistry.SetManagerState(cast.EventManagerOut)
	// m.ExternalRegistry.SetManagerState(cast.EventManagerOut)
	m.Logger.LogDebug("[Manager] out")
	return nil
}
